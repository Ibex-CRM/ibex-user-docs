{"/cabra/about":{"title":"What is going on here...","data":{"":"Cabra is the new design system that is being developed by The Goat Agency's Dev Team. It is a collection of components and styles.\nIt is a living, breathing system that is constantly being updated and improved. It is a work in progress, and we are always looking for ways to improve it.","why-is-it-called-cabra#Why is it called Cabra?":"Cabra means Goat in spanish, need I say more?","code#Code":"The Cabra repository is \"divided\" into two parts, the NPM folder and everything else.The NPM folder contains the style Tokens and React components of the Cabra system and it is our NPM package.\nSo if you need to publish a new version of our Cabra NPM Package, make sure that your terminal is working from this directory.The rest of the repository is the documentation website, which is built using Nextra.\nThe documentation website is built using MDX and the components and styles from the NPM folder.\nMDX accepts Markdown and React, so just import the components you need and use them in your markdown files.","how-to-use-cabra-npm#How to use Cabra NPM":"When creating a new component you should create a documentation page for it at the same time and import the component there.\nThis way you can see how the component looks in real time when working on it and creates the documentation at the same time.When you are done, simply write a few more lines about using the component in docs, import/export your brand new component to the index.js file and you are done.Lastly don't forget to publish the new version of the NPM package. You can do this by running npm version <new-version> and then npm publish from the NPM folder.\nnpm version 1.0.5\nnpm publish","how-to-use-cabra-docs#How to use Cabra Docs":"For this one I'm going to refer you to Nextra, because it is very well written and easy to follow. Plus you will notice that it looks very similar to this docs..."}},"/cabra/repo/github":{"title":".github / workflows","data":{"":"In this folder we keep the github workflow files that trigger the background jobs carried by github actions.\nThe workflows are triggered by events such as pull requests, pushes, etc.A few things to note:\nWhen pushing to a branch a new workflow or a modification of a workflow, the workflow that you are pushing will be the one triggered (if conditions met). If there are other workflows in the project those will be triggered too if the conditions stipulated are met.\nWhen writing a workflow the indentation is crucial as the github needs it to understand the structure of the workflow.\nThe workflows are defined in yaml files.\n\n\nname: Create Pull Request\n\non:\npush:\nbranches:\n- figma-tokens\n\njobs:\npull-request:\nruns-on: ubuntu-latest\nsteps:\n- name: Checkout\nuses: actions/checkout@v2\n\n- name: create pull request\nuses: repo-sync/pull-request@v2\nwith:\ndestination_branch: 'master'\npr_title: 'Update tokens'\npr_body: 'This is an automated pull request to update from branch figma-tokens'\npr_label: 'automerge'\ngithub_token: ${{ secrets.FIGMA_PAT }}\n\n\nIn this example workflow:\nname: this is the name of the workflow, it is used to identify the workflow in the github actions tab and to\nreference it if we need to trigger other actions connected to it.\non: this is the event that triggers the workflow. In this case the workflow is triggered when a push is made to the branch figma-tokens.\njobs: this is the list of jobs that are executed when the workflow is triggered. In this case we have only one job called pull-request.\nBut we could have more jobs in the same workflow or name it differently.\nsteps: this is the list of steps that are executed when the workflow is triggered. In this case we have to, checkout and create a pull request.\nNote that the last step has a with property that contains the parameters that are passed to the action.\n\nThis is just a quick guide an explanation, for more on github actions and workflows check out the official documentation.","cabra-workflows#Cabra workflows":"","wf1-figma-tokens-push#wf1-figma-tokens-push":"This is the first job that runs when anything is pushed to the figma-tokens branch.\nIt creates a pull request and adds a label to it. The label is needed for one of the next jobs to run.\nThe pull request requires a github personal access token (PAT) to be able to create the pull request.\nThe PAT is stored in the github repo secrets. The PAT is used to authenticate the user that creates the pull request.\nAt the moment all the pull request are created in my name (Carlos) but this can be changed in the future.","wf2-figma-tokens-pr#wf2-figma-tokens-pr":"This is the second job that runs after a pull request is created.(I know, naming could be better)\nThis job checks that the pull request is created in the figma-tokens branch.\nThen it runs the token-transformer to make the tokens readable by style-dictionary.\nThen it runs the style-dictionary to generate the tokens in the format that we will use.\nLastly it commits the changes to the figma-tokens branch.","wf3-auto-merge#wf3-auto-merge":"This jobs runs only after wf2 is completed successfully.\nThen it checks that the pull request has the label automerge.\nThen it merges the pull request to master.","wf4-deploy-docs#wf4-deploy-docs":"This job runs after wf3 is completed successfully.\nThen it builds the static site, exports it (to /out), adds a file (.nojekyll) to the root of the site and pushes it to the gh-pages branch.\nWhich is the branch that github uses to host the static site."}},"/cabra/repo/next":{"title":".next","data":{"":"This is an internal, auto generated by next folder. It contains the compiled code of your application. You should not edit this folder."}},"/cabra/repo/npm/components/components":{"title":"Components","data":{"":"We need to create a folder structure once we have components with the different types of component families"}},"/cabra/repo/next-config":{"title":"Next Config","data":{"":""}},"/cabra/repo/out":{"title":"Out","data":{"":"This is an autogenerated folder created by next export and contains the static HTML files for your application.\nDon't edit these files directly, instead use next export to generate them if needed.\nBut, normally it is generated automatically when deploying and deploying is also automated when a push to master is registered.Learn more: https://nextjs.org/docs/advanced-features/static-html-export"}},"/cabra/repo/pages/components":{"title":"Components","data":{"":""}},"/cabra/repo/npm/styles/js/variables":{"title":"Variables","data":{"":"This file is auto generated by the style dictionary. Do not edit directly. It contains the design tokens that you are going to use when creating your components\nyou can check the naming here but in most cases it will be better for you to check the naming in Figma along with the designs created by our design team.If you need to change anything about this file, check the style dictionary config file sd.config docs."}},"/cabra/repo/pages/tokens":{"title":"Tokens","data":{"":""}},"/cabra/repo/public":{"title":"Public","data":{"":""}},"/cabra/repo/sd-input":{"title":"Sd Input","data":{"":""}},"/cabra/repo/theme-config":{"title":"Theme Config","data":{"":""}},"/cabra/repo/utils":{"title":"Utils","data":{"":""}},"/ibex/BackEnd/.forestadmin-schema":{"title":".forestadmin Schema","data":{"":""}},"/ibex/BackEnd/.rubocop":{"title":".rubocop","data":{"":""}},"/ibex/BackEnd/.rspec":{"title":".rspec","data":{"":""}},"/how/write-docs":{"title":"Writing documentation","data":{"":"","why-writing-documentation-is-important#Why writing documentation is important:":"Documentation effectively connects humans and machines.\nFor you:\nYou will be using your code in 6 months\nYou want people to use your code and give you credit\nOthers would be encouraged to contribute to your code\n\n\n\n\nFor others:\nOthers can easily use your code and build upon it\n\n\n\n\n\nWhat should you document about your code? Everything! All the data, notes, code, and materials someone else would need to reproduce your work.","best-practices-for-writing-documentation#Best Practices for Writing Documentation:":"Include a README file that contains\nA brief description of the project\nInstallation instructions\nA short example/tutorial\n\n\nAllow issue tracker for others\nWrite an API documentation\nWhat a function does\nWhat are the function's parameters or arguments are\nWhat a function returns\n\n\nDocument your code\nApply coding conventions, such as file organization, comments, naming conventions, programming practices, etc.\nInclude information for contributors\nInclude licensing information\nList all the versions of the files along with the major edits you did in each version"}},"/ibex/BackEnd/.ruby-version":{"title":".ruby Version","data":{"":""}},"/ibex/BackEnd/Procfile":{"title":"Procfile","data":{"":""}},"/ibex/BackEnd/Aptfile":{"title":"Aptfile","data":{"":""}},"/ibex/BackEnd/debug.log":{"title":"Debug.log","data":{"":""}},"/ibex/BackEnd/google_client_secret":{"title":"Google Client Secret","data":{"":""}},"/ibex/FrontEnd/npmrc":{"title":"Npmrc","data":{"":""}},"/ibex/FrontEnd/semantic":{"title":"Semantic","data":{"":""}},"/ibex/BackEnd/Rakefile":{"title":"Rakefile","data":{"":""}},"/cabra/repo/sd-config":{"title":"Sd Config","data":{"":""}},"/ibex/FrontEnd/public":{"title":"Public","data":{"":""}},"/ibex/FrontEnd/src/components/Roster":{"title":"Roster","data":{"":"glossary of terms:\nCLC: Campaign List Channel","folder-structure#Folder structure:":"src/_components/Roster:  Contains the roster of section\n/_concerns: helper functions, mutations, queries, etc.\n/Board: contains the board itself, filters, list dropdown and search bar\n/Board/AppliedFilters.js: contains the list of filters applied that appears on the top of the board when filters are applied\n/Board/Card.js: contains the CLC card, a draggable item within a board lane\n/Board/index.js: board component point of entry, contains most of the logic of the board\n/Board/Options.js: contains all the filters & search bar logic\n\n\n\n\n/ChannelAddSearch: contains the channel add channel modal. This modal is used to add a new CLC to your list\n/ChannelAddSearch/Card.js: card component for the channel search results\n/ChannelAddSearch/Hits.js: contains the search results\n/ChannelAddSearch/index.js: point of entry for the search modal\n\n\n\n\n/ExclusionBoard: contains the exclusion board of the section. Not really a board(with lanes), more a cork board with cards for each excluded influencer\n/ExclusionBoard/Card.js: contains the card for the exclusion board, each contains links to open every channel of that influencer on the sidebar\n/ExclusionBoard/index.js: point of entry for the exclusion board\n\n\n\n\n/Sidebar: contains the sidebar of the section\n/Sidebar/_StyledComponents.js: contains shared styled components for the sidebar\n/Sidebar/AboutSection.js: contains the influencer about and the mutation to modify an influencers About\n/Sidebar/BioSection.js: Is here that we query for the influencers previous bios & contains the mutation to modify an influencers Bio\n/Sidebar/CampaignSection.js: It shows all the campaigns the influencer has been used, contains the \"Pill\" dropdowns and the styled components used for them\n/Sidebar/DemographicsSection.js: Shows the influencer's demographic info\n/Sidebar/index.js: point of entry for the sidebar, it has the query for the influencer we want to see in the sidebar and the logic to close the sidebar if clicking outside of it\n/Sidebar/MessagesSection.js: Shows the messages exchanged on this CLC, contains the mutation to create Messages\n/Sidebar/TagsSection.js: Shows the tags assigned to this channel\n/Sidebar/TraitsSection.js: Shows the traits assigned to this channel, contains the query and mutation to update the traits\n\n\n\n\n_StyleComponents.js: _contains shared styled components for the whole Roster\nBoardWrapper.js: contains the wrapper for the board, it contains the logic for excluding influencers and rejecting channels (including the rejection messages), it also query for the campaign Lists that this campaign has and allows you to choose which one to show on the board\nindex.js: contains the main component for the section, selection tab logic is here\nOutreachBoard.js: contains the outreach board which is still under development. For now it is very similar to an old version of the roster board and assigns every clc to the same column Needs work"}},"/ibex/FrontEnd/jsconfig":{"title":"Jsconfig","data":{"":""}},"/ibex/FrontEnd/src/components/OneOffs/podDashboard":{"title":"Poddashboard","data":{"":"explain the folder structure of the section\nwhat each folder and file is for\nhow do they connects\nhow to add new files","context#Context":"App.js:  Here I provide the UserContext to provide the user to the rest of the app\nUserContext.js: This file creates said context to pass down when using the UseContext hook\nPeripheral components modified to accommodate the new feature:\nGoatStaffModal.js: For the pod section we do not need the save and cancel btn, also small changes to style of the search bar in the modal\n/OneOffs/concerns/oneOffRoutes.js: Here we add the pod section to the sidebar in the user settings section.","all-new-files-related-to-pod-section#All new files related to Pod Section":"This section is added inside the src/_components/OneOffs because the settings are located here and the side bar too. But, if in the future we need to move it (To use as general dashboard for example) we can take the /OneOffs/PodDashboard folder and move it as the feature is self contain within this folder. Some changes on imports and exports should be all that is needed.The next list of files will be a direct representation of the file structure and a brief explanation of what they content and how they connect. For more specific information check the code & comments. Or ask Me @Carlos-Diaz-07, I'll try to help if I remember anything ðŸ‘´ ðŸ§  ðŸ”¥ ./PodDashboard:\n/_ concerns _:\nmutations.js: Contains mutations\nqueries.js: Contains queries\n\n\n/_ helpers _:\nhandleListSearch.js: The logic for the client and campaign search used for the PodSectionList shared component\n\n\n/_shared_components:\nPodSectionList.js:  This component contains the multiple lists of clients & campaigns through out this section. The search bar only appears if there are items in the list. You need to pass a handleSearch for the search functionality, the options you want to see on the list, a setSelectedOption to handle the selection of one of those options, a selectedOption if you want to highlight an option from another component and a listName for the header.\n\n\n/PodInfoSection:\nClientSelectionModal.js:  This is the client management modal, it handles two mutations, adding and removing clients from a pod.\nindex.js:  This component displays the pod information, including the crud actions for the pod leader. In this component, you'll find the add & remove pod members logic as well as the getGoatStaff query call and the handle for the search of the staff in the GoatStaffModal.js.\n\n\nCampaignDetails.js: Displays the details of campaigns\nCampaignsWithErrors.js:  We call a PodSectionList.js and it contains the logic for the search for this section.\nClientDetails.js: Displays the details of clients\nindex.js: Dashboard point of entry. useContext called to bring the user info. We also query the user's pod here and set all the necessary states to pass down.\nPodClientsSelection.js: This section contains the two main lists, clients and campaigns of that client for you to select."}},"/ibex/FrontEnd/src/ibexReactComponents/IbexDropdown":{"title":"Ibexdropdown","data":{"":"","how-to-use-ibexdropdown#How to use IbexDropdown:":"The Dropdown usage: needs at least these 3 props, optional props are explained further down\n\n\n<IbexDropdown groups={groups} selectedOptions={filterSelected} setSelectedOptions={setFilterSelected} />","props#Props":"","groups#Groups":"You should send an array with objects, each object is a group with these keys.\nLabel: each group has a label that will be use on the for the dropdown menu, so you can have any name you want.\nIcon: a FontAwesome component for the custom icon of that group.\nitems: An array of objects. This are the option people can select and you want to receive back on selectedOption It is important that the items have an id and a name.\nuniqSelect: this OPTIONAL key stops users from being able to select multiple options from a groups, in this case we add the uniqSelect to Primary Tags so users will be able to select just one primary tag\nsearch: this OPTIONAL key adds a search bar to the group, so users can search for options in that group. This is useful for large groups of options.\nrange: this OPTIONAL key adds a range min and max input fields to the group, so users can select a range of options in that group. When adding range your items array should contain only 2 objects, one for min and one for max. The id should be 1 for min and 2 for max. The name can be whatever you want, we used min and max for demo purposes.\n\n\nconst groups = [\n{\nlabel: 'Primary Tags',\nicon: <FontAwesomeIcon icon={faTag} />,\nitems: primaryTags,\nuniqSelect: true\n},\n{\nlabel: 'Tags',\nicon: <FontAwesomeIcon icon={faTags} />,\nitems: tags\n},\n{\nlabel: 'Verticals',\nicon: <FontAwesomeIcon icon={faBullseye} />,\nitems: verticals\n},\n{\nlabel: 'Platforms',\nicon: <FontAwesomeIcon icon={faBullhorn} />,\nitems: platforms\n},\n{\nlabel: 'Budget',\nicon: <FontAwesomeIcon icon={faMoneyBill} />,\nrange: true,\nitems: [\n{ id: '1', name: 'min' },\n{ id: '2', name: 'max' }\n]\n}]","selectedoptions-setselectedoptions#[selectedOptions, setSelectedOptions]":"These let you know what options the user has clicked. When the dropdown sets a selected option it will send the item object as is. The dropdown also needs awareness of which options have been selected.","results#Results:":"If we sent the above groups and the items look like so (showing just one for demo purposes):\noptions: [{\n\"__typename\": \"PrimaryTag\",\n\"id\": \"115\",\n\"name\": \"beauty\"\n}]\n\nNote: The only required fields for the items are id & name the __typename has no use for the dropdown is there for demo purposes\nYou will receive the exact same object back with and object key added, so you can add more keys to the object if you need to or use it however you need for your logic.\n{\n\"__typename\": \"PrimaryTag\",\n\"id\": \"115\",\n\"name\": \"beauty\"\n\"group\": \"beauty\"\n}\nThe results are a bit different with range, the object is the same and we add the group key but also will have a vale key with the value inserted by the user:\n{\n\"id\": \"1\",\n\"name\": \"min\"\n\"group\": \"Budget\",\n\"value\": \"100\"\n},\n{\n\"id\": \"2\",\n\"name\": \"max\"\n\"group\": \"Budget\",\n\"value\": \"55000\"\n}","optional-props#Optional Props:":"triggerComponent: This is the icon or label, or both, that the user clicks to open the dropdown. You can pass a fontawesome component or a div with text and an Icon or any other component. Be careful passing a complex component, this can result in bugs.\ntriggerComponent={<FontAwesomeIcon icon={faFilterSlash} />} or triggerComponent={<div><p>Filter</p><FontAwesomeIcon icon={faFilterSlash} /></div>}\nclearIcon: This is the icon that the user clicks to clear the dropdown selections, pass a fontawesome component\nclearIcon={<FontAwesomeIcon icon={faFilterSlash} />}\npopupContent: This is the text you want the user to see when hovering over, by default is 'Filter'. Accepts a string.\n\n-Then the dropdown would look like this. And search will be available."}},"/ibex/FrontEnd/src/api":{"title":"API","data":{"":""}},"/cabra/repo/npm":{"title":"NPM/index","data":{"":"This file is the point of entry of our NPM package when in use. It is the file that is executed when you import Cabra in your React app.\nIt is a simple file that imports all the Cabra components and exports them.\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\n// Global Components\n\nvar _TagPill2 = _interopRequireDefault(require('cabra/components/TagPill'));\nexports.TagPill = _TagPill2.default;\n\n// Roster Components\n\nvar _rosterCard2 = _interopRequireDefault(require('cabra/components/roster/card'));\nexports.rosterCard = _rosterCard2.default;\nAs you can see it requires a helper from @babel to work. Follow this pattern closely and it has proven to be reliable. And add a comment for each component family you create."}},"/ibex/FrontEnd/test-static":{"title":"Test Static","data":{"":""}},"/":{"title":"Goat Dev Docs","data":{"":"Goat Dev Docs uses Nextra, a Next.js based static site generator.It supports Markdown and React components (MDX),\nautomatically generated sidebar and anchor links, file-system based routing,\nbuilt-in syntax highlighting, image optimization, custom layouts, i18n, and all the features you love about Next.js.","why-use-nextra#Why use Nextra?":"The main reason to use Nextra and MDX for the Goat Dev Docs instead of tools\nlike Notion, which we use for other purposes, is the support of React\ncomponents inside our Markdown files. This allows us to create custom components that are specific to our documentation.At the same time we are still writing in Markdown which allows us to migrate everything to Notion\neasily, albeit with some loss of functionality.Also, everything is save in a github repository, so we can easily make changes\nand collaborate on the documentation."}},"/ibex/about":{"title":"About","data":{"":"","what-is-ibex#What is Ibex?":"Ibex is a CRM tool custom build for the GOAT agency, a influencer marketing agency. The tool is build with Ruby and React.\nThe tool is used to manage the campaigns, collect influencers information, collaborate with clients and collect the information created by campaigns."}}}